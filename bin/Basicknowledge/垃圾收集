垃圾收集算法
1.标记-清除算法
算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。
它是最基础的收集算法，会带来两个明显的问题；1：效率问题 和 2：空间问题（标记清除后会产生大量不连续的碎片）

2.复制算法
为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。
当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。

3.标记-整理算法

根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，
但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一段移动，然后直接清理掉端边界以外的内存。

4.分代收集算法
一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。
比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。
而老年代的对象存活几率是比较高的所以我们可以选择“标记-清理”或“标记-整理”算法进行垃圾收集。

垃圾收集器
根据场景选择各种垃圾收集器，才能更好的适配我们现在的各种处理环境。

Serial收集器：串行收集器不仅只会用一条线程去进行垃圾收集，并且当该收集器工作的时候其他所有工作线程都需要暂停。
虽然它停止其他线程会带来不良的用户体验，但是经过不断优化它的停顿时间大大缩短。并且由于它简单而高效，所以对于运行在Client模式下的虚拟机来说是个不错的选择。
 
ParNew收集器：Serial收集器的多线程版本，除了使用多线程外，控制参数、收集算法、回收策略都是一样的。
它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器（真正意义上的并发收集器，后面会介绍到）配合工作。

Parallel Scavenge收集器：Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的的多线程收集器。
关注点是吞吐量（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。
所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。

Serial Old收集器：
Serial收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：
一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。

Parallel Old收集器：
Parallel Scavenge收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器。

CMS收集器：CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它而非常符合在注重用户体验的应用上使用。
CMS收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：
初始标记： 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 ；
并发标记： 同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。
因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，
这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。
并发清除： 开启用户线程，同时GC线程开始对为标记的区域做清扫。

它的主要优点是并发收集、低停顿。
缺点是：对CPU资源敏感、无法处理浮动垃圾、它使用的算法在收集结束后会产生大量空间碎片。

G1收集器：上一代的垃圾收集器(串行serial, 并行parallel, 以及CMS)都把堆内存划分为固定大小的三个部分: 
年轻代(young generation), 年老代(old generation), 以及持久代(permanent generation).

并行和并发：首先G1收集器能够利用多核和CPU的硬件优势，发挥并发和并行的特点。
分代收集：虽然该收集器不需要其他收集器配合就能够独立管理GC堆，但是它还是保留了分代收集的概念。
空间整合：与CMS的“标记--清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。
可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间是G1和ＣＭＳ共同的关注点，但Ｇ１除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。

G1收集器还在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region，这也保证了它拥有尽可能高的收集效率(把内存化为0)。

内存分配与回收策略

1.对象优先在Eden区分配，当该区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。
新生代GC（Minor GC）:指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。
老年代GC（Major GC/Full GC）:指发生在老年代的GC，出现了Major GC经常会伴随至少一次的Minor GC（并非绝对），Major GC的速度一般会比Minor GC的慢10倍以上。

2.大对象直接进入老年代
大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。

3.长期存活的对象将进入老年代
既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别那些对象应放在新生代，那些对象应放在老年代中。
为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。

4.动态对象年龄判定
为了更好的适应不同程序的内存情况，虚拟机不是永远要求对象年龄必须达到了某个值才能进入老年代，
如果Survivor 空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需达到要求的年龄。