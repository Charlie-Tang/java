多个线程访问同一个类的synchronized方法时, 都是串行执行的 ! 
就算有多个cpu也不例外 ! synchronized方法使用了类java的内置锁, 即锁住的是方法所属对象本身. 
同一个锁某个时刻只能被一个执行线程所获取, 因此其他线程都得等待锁的释放. 
因此就算你有多余的cpu可以执行, 但是你没有锁, 所以你还是不能进入synchronized方法执行, CPU因此而空闲. 
如果某个线程长期持有一个竞争激烈的锁, 那么将导致其他线程都因等待所的释放而被挂起, 从而导致CPU无法得到利用, 系统吞吐量低下. 
因此要尽量避免某个线程对锁的长期占有 !


Synchronized的使用注意点：锁对象不能为空、作用域不宜过大、避免死锁
1.我们可以知道在线程初始化的时候传入的是runnable对象，当在类中所创建的对象是空的时候，当然就不会去执行run方法中的语句。
2.synchronized不能作用于过大的作用域  我们知道高并发是依赖于锁的同步资源的   当我们的作用域过大 效率就会变得低下
3.当然要避免死锁啊  我们这个锁又没有打断和跳出的方法  如果死锁的话就会一直阻塞下去

如何选择Synchronized和Lock关键字？
如果有线程的安全高并发的工具时  一般不选用这两种锁
而如果真的需要用到则选择使用Synchronized，因为它的编写比较简洁
只有真的需要灵活的锁机制时 才会选择使用Lock

多线程访问同步方法的各种情况

思考：
1.当多个线程等待一个Synchronized锁的时候，JVM是选择哪个线程获取资源呢？
由于JVM赋予锁是非公平机制  此时在等待线程资源的可能有刚被创建的  或是已经等待一段时间了的 
所以这个选择是随机的、非公平的按时间处理的

2.由于Synchronized锁只能被一个线程所持有，有什么办法能够提高使用性能吗？
我们可以限定线程的范围去持有锁 这样能够缩小权限范围  防止误操作

3.如何更灵活的去控制锁的获取和释放(由于Synchronized锁的获取和释放过于死板)

4.什么是锁的升级和降级？什么是JVM中的偏向锁、轻量级锁和重量级锁？
偏向锁--》轻量级锁--》重量级锁

如果一个单一线程总是获得该锁，为了使得线程获得该锁的费用变低引入了偏向锁。
当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，
以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。
如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：
如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。

而如果两个线程此时拥有竞争关系时 就从偏向锁变为了轻量级锁
偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，
如有必要可以使用JVM参数来关闭延迟：XX:BiasedLockingStartupDelay=0。
如果确定应用的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：
-XX:-UseBiasedLocking=false，那么程序默认会进入轻量级锁状态。

1>加锁
线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。
然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。
如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。
2>解锁
轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。
如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。

悲观锁其实一般是Synchronized和Lock关键字，而乐观锁则是使用CAS算法，在偏向锁不存在的时候进行轻量级锁转换自旋等方法，多用于
高读取型低写入程序。


