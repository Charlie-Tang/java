1.线程和进程的区别
进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。

一个程序至少有一个进程,一个进程至少有一个线程。

2.多线程的上下文切换
多线程会共同使用一组计算机上的CPU，当线程数要比CPU数大时，不同线程切换使用CPU发生的切换数据就被称为上下文切换
上下文切换是存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行。
上下文切换是多任务操作系统和多线程环境的基本特征。

3.Java中用到的线程调度算法是什么？
采用时间片轮转的方式。可以设置线程的优先级，会映射到下层的系统上面的优先级上，如非特别需要，尽量不要用，防止线程饥饿。

什么是线程组，为什么在Java中不推荐使用？
我们需要知道，线程的重复创建和销毁对于虚拟机的负担十分严重。我们使用线程组一般是在安全线程或者保密等情况使用。一般使用线程池来创建线程。

4.为什么使用Executor框架？
每次执行任务创建线程 new Thread()比较消耗性能，创建一个线程是比较耗时、耗资源的。
调用 new Thread()创建的线程缺乏管理，被称为野线程，而且可以无限制的创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源。
接使用new Thread() 启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。

5.在Java中Executor和Executors的区别？
Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。 
Executor 接口对象能执行我们的线程任务。 
ExecutorService接口继承了Executor接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。 
使用ThreadPoolExecutor 可以创建自定义线程池。 
Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的完成，并可以使用get()方法获取计算的结果。

6.什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？

原子操作（atomic operation）意为”不可被中断的一个或一系列操作” 。 
处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。 
在Java中可以通过锁和循环CAS的方式来实现原子操作。 
CAS操作——Compare & Set，或是 Compare & Swap，现在几乎所有的CPU指令都支持CAS的原子操作。
原子操作是指一个不受其他操作影响的操作任务单元。
原子操作是在多线程环境下避免数据不一致必须的手段。 
int++并不是一个原子操作，所以当一个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误。 
为了解决这个问题，必须保证增加操作是原子的，在JDK1.5之前我们可以使用同步技术来做到这一点。
到JDK1.5，java.util.concurrent.atomic包提供了int和long类型的原子包装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。
java.util.concurrent这个包里面提供了一组原子类。
其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，
执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由JVM从等待队列中选择一个另一个线程进入，
这只是一种逻辑上的理解。
原子类：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference 原子数组：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray 
原子属性更新器：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater 
解决ABA问题的原子类：AtomicMarkableReference（通过引入一个boolean来反映中间有没有变过），
AtomicStampedReference（通过引入一个int来累加来反映中间有没有变过）

7.什么是Executors框架？
Executor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。
无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。
利用Executors框架可以非常方便的创建一个线程池。

8.什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？
阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。
这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。
阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。

阻塞队列使用最经典的场景就是socket客户端数据的读取和解析，读取数据的线程不断将数据放入队列，然后解析线程不断从队列取数据解析。

9.什么是Callable和Future?
Callable接口可以被认为是带有回调的Runnable。
Future接口表示异步任务，是还没有完成的任务给出的未来结果。所以说Callable用于产生结果，Future用于获取结果。

10.什么是FutureTask?使用ExecutorService启动任务。
在Java并发程序中FutureTask表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。
只有当运算完成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。
一个FutureTask对象可以对调用了Callable和Runnable的对象进行包装，由于FutureTask也是调用了Runnable接口所以它可以提交给Executor来执行。

11.什么是并发容器的实现？
何为同步容器：可以简单地理解为通过synchronized来实现同步的容器，如果有多个线程调用同步容器的方法，它们将会串行执行。
比如Vector，Hashtable，以及Collections.synchronizedSet，synchronizedList等方法返回的容器。
而并发容器如ConcurrentHashMap采用了一种粒度更细的加锁机制，被称为分段锁，在这种锁机制下，允许任意数量的读线程并发地访问map。

12.多线程同步和互斥有几种实现方法，都是什么？
线程同步是线程间的一种依赖关系，一个线程的执行依赖另一个线程的信息。互斥则是比如锁资源的竞争。
线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，
而用户模式就是不需要切换到内核态，只在用户态完成操作。 
用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。内核模式下的方法有：事件，信号量，互斥量。

13.什么是竞争条件？你怎样发现和解决竞争？
当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，则我们认为这发生了竞争条件（race condition）。

14.为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？
当你调用start()方法时你将创建新的线程，并且执行在run()方法里的代码。 
但是如果你直接调用run()方法，它不会创建新的线程也不会执行调用线程的代码，只会把run方法当作普通方法去执行。

15.Java中你怎样唤醒一个阻塞的线程？
解决方案可以使用以对象为目标的阻塞，即利用Object类的wait()和notify()方法实现线程阻塞。 
首先，wait、notify方法是针对对象的，调用任意对象的wait()方法都将导致线程阻塞，阻塞的同时也将释放该对象的锁，相应地，
调用任意对象的notify()方法则将随机解除该对象阻塞的线程，但它需要重新获取改对象的锁，直到获取成功才能往下执行；
其次，wait、notify方法必须在synchronized块或方法中被调用，并且要保证同步块或方法的锁对象与调用wait、notify方法的对象是同一个，
如此一来在调用wait之前当前线程就已经成功获取某对象的锁，执行wait阻塞后当前线程就将之前获取的对象锁释放。

16.什么是不可变对象，它对写并发应用有什么帮助？
由于被final修饰后 其值不可变 所以它永远是线程安全的

17.Java所用到的有两种调度模型：分时调度模型和抢占式调度模型。 
分时调度模型是指让所有的线程轮流获得cpu的使用权,并且平均分配每个线程占用的CPU的时间片这个也比较好理解。
java虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，
使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃CPU。

18.如何停止一个正在运行的线程？
使用共享变量的方式 
在这种方式中，之所以引入共享变量，是因为该变量可以被多个执行相同任务的线程用来作为是否中断的信号，通知中断线程的执行。

用Thread.join()方法，或者Thread.sleep()方法，在网络中调用ServerSocket.accept()方法，或者调用了DatagramSocket.receive()方法时，
都有可能导致线程阻塞，使线程处于处于不可运行状态时

19.notify()和notifyAll()有什么区别？
当一个线程进入wait之后，就必须等其他线程notify/notifyall,使用notifyall,可以唤醒所有处于wait状态的线程，
使其重新进入锁的争夺队列中，而notify只能唤醒一个。

20.在java中wait和sleep方法的不同？
最大的不同是在等待时wait会释放锁，而sleep一直持有锁。Wait通常被用于线程间交互，sleep通常被用于暂停执行。

21.如何在两个线程间共享数据？
在两个线程间共享变量即可实现共享。 
一般来说，共享变量要求变量本身是线程安全的，然后在线程内使用的时候，如果有对共享变量的复合操作，那么也得保证复合操作的线程安全性。

22.
