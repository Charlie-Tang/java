1.按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。
一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。
Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。
一个方法不能修改一个基本数据类型的参数（即数值型或布尔型》
一个方法可以改变一个对象参数的状态。
一个方法不能让对象参数引用一个新的对象。

2.==和equals的区别
== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)
equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：
情况1：类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。
情况2：类覆盖了equals()方法。一般，我们都覆盖equals()方法来两个对象的内容相等；若它们的内容相等，则返回true(即，认为这两个对象相等)。
!String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。
!当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。

3.hashcode和equals的联系
我们知道，hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。
当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，
同时也会与其他已经加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。
但是如果发现有相同hashcode值的对象，这时会调用equals()方法来检查hashcode相等的对象是否真的相同。
如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。
！基本数据类型是没有hashCode方法的

4.sleep()方法和wait()方法简单对比
两者最主要的区别在于：sleep方法没有释放锁，而wait方法释放了锁 。
两者都可以暂停线程的执行。
Wait通常被用于线程间交互/通信，sleep通常被用于暂停执行。
wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。